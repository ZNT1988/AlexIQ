#!/usr/bin/env node

/**
 * SCAN COMPLET DES ERREURS DE SYNTAXE - HustleFinderIA
 * 
 * Script automatis√© pour d√©tecter et cat√©goriser toutes les erreurs de syntaxe
 * dans le projet HustleFinderIA (4267+ fichiers JavaScript)
 * 
 * Fonctionnalit√©s:
 * - Scan r√©cursif du dossier backend/
 * - Test syntaxe avec node --check
 * - Cat√©gorisation des erreurs par type
 * - Identification des fichiers les plus corrompus
 * - Rapport d√©taill√© avec statistiques
 * - Sauvegarde JSON du rapport
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class ScanSyntaxeComplet {
    constructor() {
        this.baseDir = path.join(__dirname, 'backend');
        this.rapport = {
            timestamp: new Date().toISOString(),
            configuration: {
                baseDirectory: this.baseDir,
                fileExtensions: ['.js'],
                scanMethod: 'node --check'
            },
            statistiques: {
                totalFichiersScann√©s: 0,
                fichiersAvecErreurs: 0,
                fichiersSansErreurs: 0,
                pourcentageCorruption: 0
            },
            erreurs: {
                total: 0,
                parType: {
                    'SyntaxError': 0,
                    'ReferenceError': 0,
                    'TypeError': 0,
                    'ImportExportError': 0,
                    'StringMalformation': 0,
                    'ObjectArraySyntax': 0,
                    'FunctionDefinition': 0,
                    'UnexpectedToken': 0,
                    'AutresErreurs': 0
                },
                d√©tails: []
            },
            fichiersProbl√©matiques: {
                top10Corrompus: [],
                parS√©v√©rit√©: {
                    critique: [],
                    √©lev√©e: [],
                    mod√©r√©e: [],
                    faible: []
                }
            },
            recommandations: []
        };
        this.fichiersJS = [];
    }

    /**
     * Point d'entr√©e principal du scan
     */
    async lancerScan() {
        console.log('üîç D√âBUT DU SCAN COMPLET DE SYNTAXE');
        console.log('=====================================');
        
        try {
            // √âtape 1: Collecter tous les fichiers JS
            console.log('üìÇ Collecte des fichiers JavaScript...');
            this.collecterFichiersJS(this.baseDir);
            
            // √âtape 2: Scanner chaque fichier
            console.log(`üîÑ Scan de ${this.fichiersJS.length} fichiers...`);
            await this.scannerTousFichiers();
            
            // √âtape 3: Analyser et cat√©goriser les r√©sultats
            console.log('üìä Analyse des r√©sultats...');
            this.analyserR√©sultats();
            
            // √âtape 4: G√©n√©rer les recommandations
            this.g√©n√©rerRecommandations();
            
            // √âtape 5: Sauvegarder le rapport
            console.log('üíæ Sauvegarde du rapport...');
            this.sauvegarderRapport();
            
            // √âtape 6: Afficher le r√©sum√©
            this.afficherR√©sum√©();
            
        } catch (erreur) {
            console.error('‚ùå Erreur lors du scan:', erreur.message);
            throw erreur;
        }
    }

    /**
     * Collecte r√©cursivement tous les fichiers .js
     */
    collecterFichiersJS(dossier) {
        if (!fs.existsSync(dossier)) {
            console.warn(`‚ö†Ô∏è Dossier non trouv√©: ${dossier}`);
            return;
        }

        const √©l√©ments = fs.readdirSync(dossier);
        
        for (const √©l√©ment of √©l√©ments) {
            const cheminComplet = path.join(dossier, √©l√©ment);
            const stats = fs.statSync(cheminComplet);
            
            if (stats.isDirectory()) {
                // Ignorer node_modules et autres dossiers syst√®me
                if (!√©l√©ment.startsWith('.') && 
                    √©l√©ment !== 'node_modules' && 
                    √©l√©ment !== 'logs' && 
                    √©l√©ment !== 'data') {
                    this.collecterFichiersJS(cheminComplet);
                }
            } else if (path.extname(√©l√©ment) === '.js') {
                this.fichiersJS.push(cheminComplet);
            }
        }
    }

    /**
     * Scanner tous les fichiers collect√©s
     */
    async scannerTousFichiers() {
        const totalFichiers = this.fichiersJS.length;
        let compteur = 0;
        
        for (const fichier of this.fichiersJS) {
            compteur++;
            
            // Afficher le progr√®s
            if (compteur % 50 === 0 || compteur === totalFichiers) {
                console.log(`   Progr√®s: ${compteur}/${totalFichiers} (${Math.round(compteur/totalFichiers*100)}%)`);
            }
            
            await this.scannerFichier(fichier);
        }
        
        this.rapport.statistiques.totalFichiersScann√©s = totalFichiers;
    }

    /**
     * Scanner un fichier individuel
     */
    async scannerFichier(cheminFichier) {
        const cheminRelatif = path.relative(this.baseDir, cheminFichier);
        
        try {
            // Test de syntaxe avec node --check
            execSync(`node --check "${cheminFichier}"`, { 
                stdio: 'pipe',
                timeout: 10000 // 10 secondes max par fichier
            });
            
            // Aucune erreur trouv√©e
            this.rapport.statistiques.fichiersSansErreurs++;
            
        } catch (erreur) {
            // Erreur de syntaxe d√©tect√©e
            this.rapport.statistiques.fichiersAvecErreurs++;
            this.rapport.erreurs.total++;
            
            const d√©tailErreur = this.analyserErreur(erreur.stderr.toString(), cheminRelatif, cheminFichier);
            this.rapport.erreurs.d√©tails.push(d√©tailErreur);
            
            // Compter par type
            this.rapport.erreurs.parType[d√©tailErreur.type]++;
        }
    }

    /**
     * Analyser et cat√©goriser une erreur
     */
    analyserErreur(messageErreur, cheminRelatif, cheminAbsolu) {
        const ligneErreur = this.extraireLigneErreur(messageErreur);
        const typeErreur = this.cat√©goriserErreur(messageErreur);
        const s√©v√©rit√© = this.√©valuerS√©v√©rit√©(messageErreur, typeErreur);
        
        return {
            fichier: cheminRelatif,
            cheminAbsolu: cheminAbsolu,
            type: typeErreur,
            s√©v√©rit√©: s√©v√©rit√©,
            ligne: ligneErreur,
            message: messageErreur.trim(),
            messageSimple: this.simplifierMessage(messageErreur),
            taille: this.obtenirTailleFichier(cheminAbsolu)
        };
    }

    /**
     * Cat√©goriser le type d'erreur
     */
    cat√©goriserErreur(message) {
        const msgLower = message.toLowerCase();
        
        if (msgLower.includes('syntaxerror')) {
            if (msgLower.includes('unexpected token')) return 'UnexpectedToken';
            if (msgLower.includes('string') || msgLower.includes('template')) return 'StringMalformation';
            if (msgLower.includes('object') || msgLower.includes('array') || msgLower.includes('{') || msgLower.includes('[')) return 'ObjectArraySyntax';
            if (msgLower.includes('function') || msgLower.includes('=>')) return 'FunctionDefinition';
            return 'SyntaxError';
        }
        
        if (msgLower.includes('referenceerror')) return 'ReferenceError';
        if (msgLower.includes('typeerror')) return 'TypeError';
        if (msgLower.includes('import') || msgLower.includes('export') || msgLower.includes('module')) return 'ImportExportError';
        
        return 'AutresErreurs';
    }

    /**
     * √âvaluer la s√©v√©rit√© d'une erreur
     */
    √©valuerS√©v√©rit√©(message, type) {
        const msgLower = message.toLowerCase();
        
        // Erreurs critiques qui cassent compl√®tement le fichier
        if (msgLower.includes('unexpected end of file') || 
            msgLower.includes('missing }') || 
            msgLower.includes('missing ]') || 
            msgLower.includes('missing )')) {
            return 'critique';
        }
        
        // Erreurs √©lev√©es
        if (type === 'SyntaxError' || type === 'UnexpectedToken') {
            return '√©lev√©e';
        }
        
        // Erreurs mod√©r√©es
        if (type === 'ReferenceError' || type === 'ImportExportError') {
            return 'mod√©r√©e';
        }
        
        // Erreurs faibles
        return 'faible';
    }

    /**
     * Extraire le num√©ro de ligne de l'erreur
     */
    extraireLigneErreur(message) {
        const match = message.match(/:(\d+):/);
        return match ? parseInt(match[1]) : null;
    }

    /**
     * Simplifier le message d'erreur
     */
    simplifierMessage(message) {
        const lignes = message.split('\n');
        return lignes[0].replace(/^.*?:\d+:\d+:\s*/, '').trim();
    }

    /**
     * Obtenir la taille du fichier
     */
    obtenirTailleFichier(chemin) {
        try {
            const stats = fs.statSync(chemin);
            return stats.size;
        } catch {
            return 0;
        }
    }

    /**
     * Analyser les r√©sultats et g√©n√©rer les statistiques
     */
    analyserR√©sultats() {
        const stats = this.rapport.statistiques;
        
        // Calculer le pourcentage de corruption
        if (stats.totalFichiersScann√©s > 0) {
            stats.pourcentageCorruption = Math.round(
                (stats.fichiersAvecErreurs / stats.totalFichiersScann√©s) * 100
            );
        }
        
        // Trier les erreurs par s√©v√©rit√© et fichier
        this.rapport.erreurs.d√©tails.sort((a, b) => {
            const s√©v√©rit√©s = { 'critique': 4, '√©lev√©e': 3, 'mod√©r√©e': 2, 'faible': 1 };
            return s√©v√©rit√©s[b.s√©v√©rit√©] - s√©v√©rit√©s[a.s√©v√©rit√©];
        });
        
        // Regrouper par fichier pour identifier les plus corrompus
        const erreursParFichier = {};
        this.rapport.erreurs.d√©tails.forEach(erreur => {
            if (!erreursParFichier[erreur.fichier]) {
                erreursParFichier[erreur.fichier] = [];
            }
            erreursParFichier[erreur.fichier].push(erreur);
        });
        
        // Top 10 des fichiers les plus corrompus
        const fichiersTri√©s = Object.entries(erreursParFichier)
            .map(([fichier, erreurs]) => ({
                fichier,
                nombreErreurs: erreurs.length,
                s√©v√©rit√©Max: this.obtenirS√©v√©rit√©Max(erreurs),
                erreurs: erreurs
            }))
            .sort((a, b) => {
                const s√©v√©rit√©s = { 'critique': 4, '√©lev√©e': 3, 'mod√©r√©e': 2, 'faible': 1 };
                if (s√©v√©rit√©s[b.s√©v√©rit√©Max] !== s√©v√©rit√©s[a.s√©v√©rit√©Max]) {
                    return s√©v√©rit√©s[b.s√©v√©rit√©Max] - s√©v√©rit√©s[a.s√©v√©rit√©Max];
                }
                return b.nombreErreurs - a.nombreErreurs;
            });
        
        this.rapport.fichiersProbl√©matiques.top10Corrompus = fichiersTri√©s.slice(0, 10);
        
        // Regrouper par s√©v√©rit√©
        this.rapport.erreurs.d√©tails.forEach(erreur => {
            this.rapport.fichiersProbl√©matiques.parS√©v√©rit√©[erreur.s√©v√©rit√©].push(erreur);
        });
    }

    /**
     * Obtenir la s√©v√©rit√© maximale d'un groupe d'erreurs
     */
    obtenirS√©v√©rit√©Max(erreurs) {
        const s√©v√©rit√©s = { 'critique': 4, '√©lev√©e': 3, 'mod√©r√©e': 2, 'faible': 1 };
        let maxS√©v = 0;
        let r√©sultat = 'faible';
        
        erreurs.forEach(erreur => {
            if (s√©v√©rit√©s[erreur.s√©v√©rit√©] > maxS√©v) {
                maxS√©v = s√©v√©rit√©s[erreur.s√©v√©rit√©];
                r√©sultat = erreur.s√©v√©rit√©;
            }
        });
        
        return r√©sultat;
    }

    /**
     * G√©n√©rer les recommandations
     */
    g√©n√©rerRecommandations() {
        const stats = this.rapport.statistiques;
        const erreurs = this.rapport.erreurs;
        
        this.rapport.recommandations = [
            `üìä √âTAT DU PROJET: ${stats.pourcentageCorruption}% de fichiers corrompus (${stats.fichiersAvecErreurs}/${stats.totalFichiersScann√©s})`,
            
            // Recommandations bas√©es sur le taux de corruption
            stats.pourcentageCorruption > 75 ? 
                "üö® CRITIQUE: Refactoring complet n√©cessaire" :
            stats.pourcentageCorruption > 50 ? 
                "‚ö†Ô∏è URGENT: Correction massive requise" :
            stats.pourcentageCorruption > 25 ? 
                "üîß IMPORTANT: Plan de correction syst√©matique" :
                "‚úÖ ACCEPTABLE: Corrections ponctuelles suffisantes",
            
            // Recommandations par type d'erreur
            erreurs.parType.SyntaxError > erreurs.total * 0.4 ? 
                "üîç Prioriser la correction des erreurs de syntaxe de base" : null,
            
            erreurs.parType.UnexpectedToken > erreurs.total * 0.3 ? 
                "üîß Focus sur les tokens inattendus (accolades, parenth√®ses)" : null,
            
            erreurs.parType.StringMalformation > erreurs.total * 0.2 ? 
                "üìù Corriger les cha√Ænes de caract√®res malform√©es" : null,
            
            // Plan d'action
            "üéØ PLAN D'ACTION RECOMMAND√â:",
            "   1. Traiter d'abord les erreurs CRITIQUES",
            "   2. Corriger les fichiers du Top 10",
            "   3. Automatiser les corrections r√©p√©titives",
            "   4. Mettre en place des tests de syntaxe",
            "   5. Configurer des hooks de pre-commit"
        ].filter(Boolean);
    }

    /**
     * Sauvegarder le rapport en JSON
     */
    sauvegarderRapport() {
        const nomFichier = 'scan-erreurs-syntaxe.json';
        const contenu = JSON.stringify(this.rapport, null, 2);
        
        fs.writeFileSync(nomFichier, contenu, 'utf8');
        console.log(`üìÑ Rapport sauvegard√©: ${nomFichier}`);
    }

    /**
     * Afficher le r√©sum√© des r√©sultats
     */
    afficherR√©sum√©() {
        const stats = this.rapport.statistiques;
        const erreurs = this.rapport.erreurs;
        
        console.log('\nüéØ R√âSUM√â DU SCAN DE SYNTAXE');
        console.log('=====================================');
        console.log(`üìÇ Fichiers scann√©s: ${stats.totalFichiersScann√©s}`);
        console.log(`‚ùå Fichiers avec erreurs: ${stats.fichiersAvecErreurs}`);
        console.log(`‚úÖ Fichiers sans erreurs: ${stats.fichiersSansErreurs}`);
        console.log(`üìä Taux de corruption: ${stats.pourcentageCorruption}%`);
        console.log(`üî¢ Total erreurs: ${erreurs.total}`);
        
        console.log('\nüìà R√âPARTITION PAR TYPE:');
        console.log('-------------------------');
        Object.entries(erreurs.parType).forEach(([type, count]) => {
            if (count > 0) {
                const pourcentage = Math.round((count / erreurs.total) * 100);
                console.log(`   ${type}: ${count} (${pourcentage}%)`);
            }
        });
        
        console.log('\nüî• TOP 5 FICHIERS LES PLUS CORROMPUS:');
        console.log('-------------------------------------');
        this.rapport.fichiersProbl√©matiques.top10Corrompus.slice(0, 5).forEach((fichier, index) => {
            console.log(`   ${index + 1}. ${fichier.fichier} (${fichier.nombreErreurs} erreurs, s√©v√©rit√©: ${fichier.s√©v√©rit√©Max})`);
        });
        
        console.log('\nüí° RECOMMANDATIONS:');
        console.log('-------------------');
        this.rapport.recommandations.forEach(rec => {
            console.log(`   ${rec}`);
        });
        
        console.log('\n‚ú® Scan termin√© avec succ√®s!');
        console.log(`üìÑ Rapport d√©taill√© disponible dans: scan-erreurs-syntaxe.json`);
    }
}

// Ex√©cution du script
if (require.main === module) {
    const scanner = new ScanSyntaxeComplet();
    
    scanner.lancerScan().catch(erreur => {
        console.error('üí• Erreur fatale:', erreur);
        process.exit(1);
    });
}

module.exports = ScanSyntaxeComplet;