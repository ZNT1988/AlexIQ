#!/usr/bin/env node

/**
 * CORRECTION D'URGENCE - MODULES CORE
 * 
 * Script de correction manuelle pour les 5 fichiers les plus critiques
 * qui emp√™chent le fonctionnement de base de l'application
 */

const fs = require('fs');
const path = require('path');

class CorrectionUrgenceCore {
    constructor() {
        this.corrections = {
            total: 0,
            r√©ussies: 0,
            √©chou√©es: 0,
            d√©tails: []
        };
        
        // Fichiers critiques √† corriger en priorit√©
        this.fichiersCore = [
            {
                chemin: 'alex-core\\AlexKernel.js',
                priority: 'CRITIQUE',
                description: 'Noyau principal - Variables avec mots r√©serv√©s'
            },
            {
                chemin: 'alex-core\\UniversalModuleRegistry.js', 
                priority: 'CRITIQUE',
                description: 'Registre modules - Variables r√©serv√©es'
            },
            {
                chemin: 'alex-core\\LicorneOrchestrator.js',
                priority: 'CRITIQUE', 
                description: 'Orchestrateur - Requires malform√©s'
            },
            {
                chemin: 'routes\\real-alex.js',
                priority: '√âLEV√âE',
                description: 'Route principale API'
            },
            {
                chemin: 'middleware\\errorHandler.js',
                priority: '√âLEV√âE',
                description: 'Gestionnaire erreurs global'
            }
        ];
    }

    /**
     * Corriger les variables avec mots r√©serv√©s
     */
    corrigerMotsR√©serv√©s(contenu) {
        let r√©sultat = contenu;
        let corrections = 0;
        
        // Pattern: let + mot r√©serv√© + commentaire
        const patterns = [
            { regex: /let\s+true\s*;\s*\/\/\s*Variable auto-d√©clar√©e/g, replace: 'let isTrue; // Variable auto-d√©clar√©e' },
            { regex: /let\s+false\s*;\s*\/\/\s*Variable auto-d√©clar√©e/g, replace: 'let isFalse; // Variable auto-d√©clar√©e' },
            { regex: /let\s+continue\s*;\s*\/\/\s*Variable auto-d√©clar√©e/g, replace: 'let shouldContinue; // Variable auto-d√©clar√©e' },
            { regex: /let\s+return\s*;\s*\/\/\s*Variable auto-d√©clar√©e/g, replace: 'let returnValue; // Variable auto-d√©clar√©e' },
            { regex: /let\s+function\s*;\s*\/\/\s*Variable auto-d√©clar√©e/g, replace: 'let functionRef; // Variable auto-d√©clar√©e' },
            { regex: /let\s+class\s*;\s*\/\/\s*Variable auto-d√©clar√©e/g, replace: 'let classRef; // Variable auto-d√©clar√©e' },
            { regex: /let\s+const\s*;\s*\/\/\s*Variable auto-d√©clar√©e/g, replace: 'let constantRef; // Variable auto-d√©clar√©e' },
            { regex: /let\s+var\s*;\s*\/\/\s*Variable auto-d√©clar√©e/g, replace: 'let variableRef; // Variable auto-d√©clar√©e' }
        ];
        
        for (const pattern of patterns) {
            if (pattern.regex.test(r√©sultat)) {
                r√©sultat = r√©sultat.replace(pattern.regex, pattern.replace);
                corrections++;
            }
        }
        
        return { contenu: r√©sultat, corrections };
    }

    /**
     * Corriger les requires concat√©n√©s
     */
    corrigerRequiresConcat√©n√©s(contenu) {
        let r√©sultat = contenu;
        let corrections = 0;
        
        // Pattern sp√©cifique pour EventEmitter + config + sqlite3
        const patternComplex = /const\s+EventEmitter\s*=\s*require\s*\(\s*["']events["']\s*\)\s*;\s*['"]\s*const\s+config\s*=\s*require\s*\(\s*["']([^"']*?)["']\s*\)\s*;\s*['"]\s*\/g\s*const\s+sqlite3\s*=\s*require\s*\(\s*["']sqlite3["']\s*\)\.verbose\(\)\s*;\s*['"]/;
        
        if (patternComplex.test(r√©sultat)) {
            r√©sultat = r√©sultat.replace(patternComplex, 
                `const EventEmitter = require("events");
const config = require("$1");
const sqlite3 = require("sqlite3").verbose();`);
            corrections++;
        }
        
        // Pattern g√©n√©ral pour requires avec guillemets √©tranges
        r√©sultat = r√©sultat.replace(/const\s+(\w+)\s*=\s*require\s*\(\s*["']([^"']*?)["']\s*\)\s*;\s*['"]\s*/g, 'const $1 = require("$2");');
        
        return { contenu: r√©sultat, corrections };
    }

    /**
     * Corriger les objets malform√©s
     */
    corrigerObjetsmalform√©s(contenu) {
        let r√©sultat = contenu;
        let corrections = 0;
        
        // Pattern: const task = "{"
        r√©sultat = r√©sultat.replace(/const\s+(\w+)\s*=\s*['"]\{['"]\s*;/g, 'const $1 = {');
        
        // Pattern: status: "pending","
        r√©sultat = r√©sultat.replace(/(\w+):\s*["']([^"']*?)["']\s*,\s*["']\s*/g, '$1: "$2",');
        
        // Pattern: }"; au lieu de }
        r√©sultat = r√©sultat.replace(/\}\s*['"]\s*;/g, '};');
        
        return { contenu: r√©sultat, corrections };
    }

    /**
     * Corriger les tableaux malform√©s
     */
    corrigerTableauxMalform√©s(contenu) {
        let r√©sultat = contenu;
        let corrections = 0;
        
        // Pattern: const array = "["
        r√©sultat = r√©sultat.replace(/const\s+(\w+)\s*=\s*['"]\[['"]\s*;/g, 'const $1 = [');
        
        // Pattern: ]"; au lieu de ]
        r√©sultat = r√©sultat.replace(/\]\s*['"]\s*;/g, '];');
        
        return { contenu: r√©sultat, corrections };
    }

    /**
     * Corriger les cha√Ænes avec guillemets √©tranges
     */
    corrigerGuillemets√âtranges(contenu) {
        let r√©sultat = contenu;
        let corrections = 0;
        
        // Nettoyer les doubles guillemets
        r√©sultat = r√©sultat.replace(/['"]{2,}/g, '"');
        
        // Corriger les √©chappements incorrects
        r√©sultat = r√©sultat.replace(/\\['"]/g, '"');
        
        // Corriger les points-virgules dans les cha√Ænes
        r√©sultat = r√©sultat.replace(/(['"]);(['"]),/g, '$1$2,');
        
        return { contenu: r√©sultat, corrections };
    }

    /**
     * Corriger un fichier sp√©cifique
     */
    async corrigerFichier(fichierInfo) {
        const cheminAbsolu = path.join(__dirname, 'backend', fichierInfo.chemin);
        console.log(`\nüîß Correction de ${fichierInfo.chemin} (${fichierInfo.priority})`);
        
        try {
            if (!fs.existsSync(cheminAbsolu)) {
                throw new Error(`Fichier non trouv√©: ${cheminAbsolu}`);
            }
            
            const contenuOriginal = fs.readFileSync(cheminAbsolu, 'utf8');
            let contenuCorrig√© = contenuOriginal;
            let totalCorrections = 0;
            
            // Cr√©er sauvegarde
            const cheminBackup = cheminAbsolu + '.backup-urgence';
            fs.writeFileSync(cheminBackup, contenuOriginal);
            console.log(`   üíæ Sauvegarde cr√©√©e: ${path.basename(cheminBackup)}`);
            
            // Appliquer toutes les corrections
            const corrections = [
                this.corrigerMotsR√©serv√©s(contenuCorrig√©),
                this.corrigerRequiresConcat√©n√©s(contenuCorrig√©),
                this.corrigerObjetsmalform√©s(contenuCorrig√©),
                this.corrigerTableauxMalform√©s(contenuCorrig√©),
                this.corrigerGuillemets√âtranges(contenuCorrig√©)
            ];
            
            contenuCorrig√© = corrections.reduce((acc, correction, index) => {
                const nouveauContenu = index === 0 ? correction.contenu : 
                    corrections[index - 1].contenu === acc ? correction.contenu : acc;
                totalCorrections += correction.corrections;
                return nouveauContenu;
            }, contenuCorrig√©);
            
            // Sauvegarder les modifications
            if (contenuCorrig√© !== contenuOriginal) {
                fs.writeFileSync(cheminAbsolu, contenuCorrig√©);
                console.log(`   ‚úèÔ∏è ${totalCorrections} corrections appliqu√©es`);
                
                // Tester la syntaxe
                const syntaxeValide = await this.testerSyntaxe(cheminAbsolu);
                
                if (syntaxeValide) {
                    console.log(`   ‚úÖ Syntaxe valide apr√®s correction`);
                    this.corrections.r√©ussies++;
                } else {
                    console.log(`   ‚ùå Syntaxe toujours invalide, restauration...`);
                    fs.writeFileSync(cheminAbsolu, contenuOriginal);
                    this.corrections.√©chou√©es++;
                }
                
                this.corrections.d√©tails.push({
                    fichier: fichierInfo.chemin,
                    corrections: totalCorrections,
                    syntaxeValide: syntaxeValide,
                    taille: {
                        avant: contenuOriginal.length,
                        apr√®s: contenuCorrig√©.length
                    }
                });
                
            } else {
                console.log(`   ‚ÑπÔ∏è Aucune correction applicable automatiquement`);
            }
            
        } catch (erreur) {
            console.error(`   ‚ùå Erreur: ${erreur.message}`);
            this.corrections.√©chou√©es++;
        }
    }

    /**
     * Tester la syntaxe d'un fichier
     */
    async testerSyntaxe(cheminFichier) {
        try {
            const { execSync } = require('child_process');
            execSync(`node --check "${cheminFichier}"`, { stdio: 'pipe', timeout: 10000 });
            return true;
        } catch {
            return false;
        }
    }

    /**
     * Ex√©cuter la correction d'urgence
     */
    async ex√©cuter() {
        console.log('üö® CORRECTION D\'URGENCE - MODULES CORE');
        console.log('=======================================');
        console.log('‚ö†Ô∏è Cette correction traite les erreurs les plus critiques');
        console.log('‚ö†Ô∏è Les sauvegardes seront cr√©√©es automatiquement\n');
        
        // Traiter chaque fichier critique
        for (const fichier of this.fichiersCore) {
            await this.corrigerFichier(fichier);
            this.corrections.total++;
            
            // Petite pause entre les fichiers
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // G√©n√©rer le rapport final
        this.g√©n√©rerRapportUrgence();
    }

    /**
     * G√©n√©rer le rapport de correction d'urgence
     */
    g√©n√©rerRapportUrgence() {
        const rapport = {
            timestamp: new Date().toISOString(),
            type: 'CORRECTION_URGENCE_CORE',
            r√©sultats: {
                fichiersTrait√©s: this.corrections.total,
                correctionsR√©ussies: this.corrections.r√©ussies,
                corrections√âchou√©es: this.corrections.√©chou√©es,
                tauxSucc√®s: this.corrections.total > 0 ? 
                    Math.round((this.corrections.r√©ussies / this.corrections.total) * 100) : 0
            },
            d√©tails: this.corrections.d√©tails,
            prochainesTouches: [
                'Relancer le scan de syntaxe complet',
                'Tester le d√©marrage de l\'application', 
                'V√©rifier les fonctionnalit√©s core',
                'Corriger les fichiers secondaires',
                'Impl√©menter la validation continue'
            ]
        };
        
        fs.writeFileSync('rapport-correction-urgence.json', JSON.stringify(rapport, null, 2));
        
        // Affichage du r√©sum√©
        console.log('\nüéØ R√âSUM√â CORRECTION D\'URGENCE');
        console.log('==============================');
        console.log(`üìÅ Fichiers trait√©s: ${rapport.r√©sultats.fichiersTrait√©s}`);
        console.log(`‚úÖ Corrections r√©ussies: ${rapport.r√©sultats.correctionsR√©ussies}`);
        console.log(`‚ùå Corrections √©chou√©es: ${rapport.r√©sultats.corrections√âchou√©es}`);
        console.log(`üìà Taux de succ√®s: ${rapport.r√©sultats.tauxSucc√®s}%`);
        
        if (rapport.r√©sultats.correctionsR√©ussies > 0) {
            console.log('\nüéâ Quelques fichiers core ont √©t√© corrig√©s avec succ√®s!');
            console.log('üìã Prochaines √©tapes:');
            rapport.prochainesTouches.forEach((√©tape, i) => {
                console.log(`   ${i + 1}. ${√©tape}`);
            });
        } else {
            console.log('\n‚ö†Ô∏è Aucune correction automatique n\'a r√©ussi.');
            console.log('üë®‚Äçüíª Intervention manuelle n√©cessaire pour ces fichiers.');
        }
        
        console.log(`\nüìÑ Rapport d√©taill√©: rapport-correction-urgence.json`);
    }
}

// Ex√©cution du script
if (require.main === module) {
    const correcteur = new CorrectionUrgenceCore();
    
    correcteur.ex√©cuter().catch(erreur => {
        console.error('üí• Erreur fatale lors de la correction d\'urgence:', erreur);
        process.exit(1);
    });
}

module.exports = CorrectionUrgenceCore;