#!/usr/bin/env node

/**
 * CORRECTEUR AUTOMATIQUE - GUILLEMETS MALFORM√âS
 * 
 * Script pour corriger automatiquement les guillemets malform√©s
 * identifi√©s dans le scan de syntaxe (35 erreurs, impact √âLEV√â)
 */

const fs = require('fs');
const path = require('path');

class FixQuotesMalformation {
    constructor() {
        this.rapport = null;
        this.corrections = {
            total: 0,
            r√©ussies: 0,
            √©chou√©es: 0,
            fichiers: new Set(),
            d√©tails: []
        };
        
        // Patterns de correction pour les guillemets
        this.patternsCorrection = [
            // Pattern 1: ';' √† la fin des cha√Ænes
            { regex: /(\w+)\s*=\s*(['"])(.*?)\2\s*;\s*['"]\s*;/g, replace: '$1 = $2$3$2;' },
            
            // Pattern 2: Guillemets doubles avec points-virgules
            { regex: /(['"])(.*?)\1\s*;\s*['"]([^'"]*)/g, replace: '$1$2$3$1' },
            
            // Pattern 3: EventEmitter avec guillemet √©trange
            { regex: /const\s+(\w+)\s*=\s*require\s*\(\s*["']([^"']*?)["']\s*\)\s*;\s*['"]\s*/g, replace: 'const $1 = require("$2");' },
            
            // Pattern 4: Cha√Ænes avec \' et \" m√©lang√©s
            { regex: /(['"])(.*?)\\(['"])(.*?)\s*\\(['"])(.*?)\1/g, replace: '$1$2$4$6$1' },
            
            // Pattern 5: Points-virgules dans les cha√Ænes
            { regex: /(['"])(.*?);['"](.*?)(['"])/g, replace: '$1$2$3$4' },
            
            // Pattern 6: Doubles guillemets √©tranges
            { regex: /["']["']/g, replace: '"' },
            
            // Pattern 7: √âchappement incorrect
            { regex: /\\(['"])/g, replace: '$1' },
            
            // Pattern 8: Espaces avant guillemets de fermeture
            { regex: /([^\\])\s+(['"])\s*;/g, replace: '$1$2;' }
        ];
    }

    /**
     * Charger le rapport d'analyse
     */
    chargerRapport() {
        try {
            const contenu = fs.readFileSync('analyse-patterns-erreurs.json', 'utf8');
            this.rapport = JSON.parse(contenu);
            console.log(`‚úÖ Rapport d'analyse charg√©`);
        } catch (erreur) {
            throw new Error(`Impossible de charger le rapport d'analyse: ${erreur.message}`);
        }
    }

    /**
     * Identifier les fichiers avec des guillemets malform√©s
     */
    identifierFichiers() {
        const pattern = this.rapport.patterns.quotes_malformees;
        if (!pattern || pattern.count === 0) {
            console.log('‚ÑπÔ∏è Aucune erreur de guillemets malform√©s trouv√©e');
            return [];
        }
        
        // D√©duplication des fichiers
        const fichiersUniques = [...new Set(pattern.files)];
        console.log(`üéØ ${fichiersUniques.length} fichiers avec guillemets malform√©s identifi√©s`);
        
        return fichiersUniques;
    }

    /**
     * Corriger un fichier sp√©cifique
     */
    async corrigerFichier(cheminRelatif) {
        const cheminAbsolu = path.join(__dirname, 'backend', cheminRelatif);
        
        try {
            // Lire le contenu original
            if (!fs.existsSync(cheminAbsolu)) {
                throw new Error(`Fichier non trouv√©: ${cheminAbsolu}`);
            }
            
            const contenuOriginal = fs.readFileSync(cheminAbsolu, 'utf8');
            let contenuCorrig√© = contenuOriginal;
            let modificationsAppliqu√©es = 0;
            
            // Cr√©er une sauvegarde
            const cheminBackup = cheminAbsolu + '.backup-quotes';
            fs.writeFileSync(cheminBackup, contenuOriginal);
            
            // Appliquer chaque pattern de correction
            for (const pattern of this.patternsCorrection) {
                const matches = contenuCorrig√©.match(pattern.regex);
                if (matches) {
                    const nouveauContenu = contenuCorrig√©.replace(pattern.regex, pattern.replace);
                    if (nouveauContenu !== contenuCorrig√©) {
                        contenuCorrig√© = nouveauContenu;
                        modificationsAppliqu√©es += matches.length;
                    }
                }
            }
            
            // Corrections sp√©cifiques suppl√©mentaires
            contenuCorrig√© = this.correctionsSp√©cifiques(contenuCorrig√©);
            
            // Sauvegarder si des modifications ont √©t√© apport√©es
            if (contenuCorrig√© !== contenuOriginal) {
                fs.writeFileSync(cheminAbsolu, contenuCorrig√©);
                
                // Tester la syntaxe du fichier corrig√©
                const syntaxeValide = await this.testerSyntaxe(cheminAbsolu);
                
                const d√©tail = {
                    fichier: cheminRelatif,
                    modifications: modificationsAppliqu√©es,
                    syntaxeValide: syntaxeValide,
                    taille: {
                        avant: contenuOriginal.length,
                        apr√®s: contenuCorrig√©.length
                    }
                };
                
                if (syntaxeValide) {
                    this.corrections.r√©ussies++;
                    console.log(`   ‚úÖ ${cheminRelatif} - ${modificationsAppliqu√©es} corrections appliqu√©es`);
                } else {
                    // Restaurer la sauvegarde si la syntaxe est cass√©e
                    fs.writeFileSync(cheminAbsolu, contenuOriginal);
                    this.corrections.√©chou√©es++;
                    console.log(`   ‚ùå ${cheminRelatif} - Syntaxe cass√©e, restauration automatique`);
                }
                
                this.corrections.d√©tails.push(d√©tail);
                this.corrections.fichiers.add(cheminRelatif);
                
            } else {
                console.log(`   ‚ÑπÔ∏è ${cheminRelatif} - Aucune correction automatique applicable`);
            }
            
        } catch (erreur) {
            console.error(`   ‚ùå Erreur lors de la correction de ${cheminRelatif}: ${erreur.message}`);
            this.corrections.√©chou√©es++;
        }
    }

    /**
     * Corrections sp√©cifiques pour certains patterns courants
     */
    correctionsSp√©cifiques(contenu) {
        let r√©sultat = contenu;
        
        // Correction 1: EventEmitter avec guillemet √©trange √† la fin
        r√©sultat = r√©sultat.replace(
            /const\s+EventEmitter\s*=\s*require\s*\(\s*["']events["']\s*\)\s*;\s*["']\s*;?/g,
            'const EventEmitter = require("events");'
        );
        
        // Correction 2: Imports avec guillemets malform√©s
        r√©sultat = r√©sultat.replace(
            /import\s+(\w+)\s+from\s+["']([^"']*?)["']\s*;\s*['"]\s+import/g,
            'import $1 from "$2";\nimport'
        );
        
        // Correction 3: URLs avec guillemets √©chapp√©s incorrectement
        r√©sultat = r√©sultat.replace(
            /https?:\\?\/\\?\/?([^'"]*?)\\?['"]['"]/g,
            'https://$1'
        );
        
        // Correction 4: Points-virgules en trop dans les cha√Ænes
        r√©sultat = r√©sultat.replace(
            /(['"])(.*?);(['"]),\s*\\?(['"])/g,
            '$1$2$3$4'
        );
        
        return r√©sultat;
    }

    /**
     * Tester la syntaxe d'un fichier
     */
    async testerSyntaxe(cheminFichier) {
        try {
            const { execSync } = require('child_process');
            execSync(`node --check "${cheminFichier}"`, { stdio: 'pipe', timeout: 5000 });
            return true;
        } catch {
            return false;
        }
    }

    /**
     * G√©n√©rer le rapport de corrections
     */
    g√©n√©rerRapport() {
        const rapport = {
            timestamp: new Date().toISOString(),
            script: 'fix-quotes-malformation.cjs',
            objectif: 'Correction automatique des guillemets malform√©s',
            r√©sultats: {
                fichiersTrait√©s: this.corrections.fichiers.size,
                correctionsR√©ussies: this.corrections.r√©ussies,
                corrections√âchou√©es: this.corrections.√©chou√©es,
                tauxSucc√®s: this.corrections.fichiers.size > 0 ? 
                    Math.round((this.corrections.r√©ussies / this.corrections.fichiers.size) * 100) : 0
            },
            d√©tails: this.corrections.d√©tails,
            recommandations: [
                this.corrections.√©chou√©es > 0 ? 
                    `‚ö†Ô∏è ${this.corrections.√©chou√©es} corrections ont √©chou√© - r√©vision manuelle n√©cessaire` : 
                    '‚úÖ Toutes les corrections automatiques ont r√©ussi',
                
                'üîÑ Relancer le scan de syntaxe pour v√©rifier les am√©liorations',
                'üß™ Ex√©cuter les tests pour valider les corrections',
                'üöÄ Passer au pattern suivant: duplicate_declarations'
            ]
        };
        
        return rapport;
    }

    /**
     * Ex√©cuter la correction automatique
     */
    async ex√©cuter() {
        console.log('üîß CORRECTION AUTOMATIQUE - GUILLEMETS MALFORM√âS');
        console.log('==================================================');
        
        try {
            // Charger le rapport d'analyse
            this.chargerRapport();
            
            // Identifier les fichiers √† corriger
            const fichiers = this.identifierFichiers();
            
            if (fichiers.length === 0) {
                console.log('‚úÖ Aucun fichier √† corriger');
                return;
            }
            
            console.log(`üîÑ Correction de ${fichiers.length} fichiers...`);
            
            // Corriger chaque fichier
            for (const fichier of fichiers) {
                await this.corrigerFichier(fichier);
                this.corrections.total++;
            }
            
            // G√©n√©rer le rapport
            const rapport = this.g√©n√©rerRapport();
            const nomFichier = 'rapport-fix-quotes.json';
            fs.writeFileSync(nomFichier, JSON.stringify(rapport, null, 2));
            
            // Afficher le r√©sum√©
            console.log('\nüìä R√âSUM√â DES CORRECTIONS');
            console.log('==========================');
            console.log(`üìÅ Fichiers trait√©s: ${rapport.r√©sultats.fichiersTrait√©s}`);
            console.log(`‚úÖ Corrections r√©ussies: ${rapport.r√©sultats.correctionsR√©ussies}`);
            console.log(`‚ùå Corrections √©chou√©es: ${rapport.r√©sultats.corrections√âchou√©es}`);
            console.log(`üìà Taux de succ√®s: ${rapport.r√©sultats.tauxSucc√®s}%`);
            
            console.log('\nüí° PROCHAINES √âTAPES:');
            rapport.recommandations.forEach(rec => console.log(`   ${rec}`));
            
            console.log(`\nüìÑ Rapport d√©taill√©: ${nomFichier}`);
            
        } catch (erreur) {
            console.error('‚ùå Erreur lors de la correction:', erreur.message);
            throw erreur;
        }
    }
}

// Ex√©cution du script
if (require.main === module) {
    const correcteur = new FixQuotesMalformation();
    
    correcteur.ex√©cuter().catch(erreur => {
        console.error('üí• Erreur fatale:', erreur);
        process.exit(1);
    });
}

module.exports = FixQuotesMalformation;